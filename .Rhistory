# that are displayed on the screen, so math.
#
# math proof comp. sci. style (for funsies) ##########################
# if:
# x_[a,n,b], y_[a,n,b] exists in world
# s.t. x_[1, .., n], y_[1, .., n] exists for all x that exist on screen
# then:
# f(x,y) = TRUE
#        = x_a <= x_n <= x_b
#    and y_a <= y_1n <= y_b
# got function from the courtosy of:e
InBounds <- reactive({
if (is.null(input$map_bounds)){
# change to my data?
return(onscreen_plotdata[FALSE,])
}
bounds <- input$map_bounds # user screen map bounds
# scraping [x_a, x_b]
lat_rng <- range(bounds$north, bounds$south)
# getting [x_a, x_b]
long_rng <- range(bounds$east, bounds$west)
# subset dataframe
# for <blah> plots
return (
onscreen_plotdata %>%
subset(
lat >= lat_rng[1]
&lat <= lat_rng[2]
&long >= long_rng[1]
&long <= long_rng[2]
)
)
})
###### 2. Leaflet Map
output$leafletMap <- renderLeaflet({
# coord for rough middle of plot
# for map reboot, in middle of types chosen
viewLatLong <- raw %>%
subset(type %in% input$usrTypes) %>%
summarise(
meanlat = mean(lat)
,meanlong = mean(long)
)
# can add option for middle of user screen
# based on global option for screen adjust
# mutate data for user input of object types
df <- raw %>%
subset(input$usrTypes == type)
## color function for continuous data based on itemsTagged
colorContinuous <- colorBin(
# function for color of collection types
palette =
c(
"#E935f2" # diverging CCDA25 # rubbish E935f2
,"#F6A2FC" # lightpink F4B2F8
)
############################################### # #
# add option to change this depending on screen
############################################### # #
,domain = c(1,250)
,bins = 2
,reverse = TRUE
# ,pretty = TRUE
)
df %>%
# send data to leaflet map
leaflet(
## global map settings
# size settings
width = "100%"
,height = "100%"
) %>%
setView(
# set initial view to middle of data
lng= viewLatLong[['meanlong']]
,lat= viewLatLong[['meanlat']]
# initial zoom, fits all points
,zoom= 15.2
) %>%
addProviderTiles(
# backgrounds
"CartoDB.DarkMatter"
# ,"Stamen.Toner"
) %>%
addCircles(
# circle settings
lng = ~long
,lat = ~lat
,radius = ~itemsTagged*0.2
,color = ~colorContinuous(itemsTagged)
)
})
})
# ##### 1. Treemap of object sizes
# output$treeMap <- renderD3tree2({
#
#   # get totals for all types
#   total <- raw %>%
#     subset(type %in% input$usrTypes) %>%
#     summarise(
#       total = sum(itemsTagged)
#     ) %>%
#     as.numeric()
#
#   # create base png treemap
#   treemap <- raw %>%
#     # manipulate data
#     subset(type %in% input$usrTypes) %>%
#     group_by(type, street) %>%
#     summarise(
#       count = sum(itemsTagged)
#       ,percent = sum(itemsTagged)/total*100
#     ) %>%
#     arrange(-count) %>%
#     # call basic tree map
#     treemap(
#       # base settings
#       index=c('type', 'street')
#       ,draw = FALSE
#       ,force.print.labels = FALSE
#       ,vSize = 'count'
#       #,vColor = 'color'
#       ,type ="index"
#       ,palette = "Set2"
#       ,bg.labels = c("white")
#       ,align.labels = list(
#         c("center", "center"),
#         c("right", "bottom")
#       )
#     )
#
#   # create interactive treemap
#   treemap %>%
#     d3tree2(
#       rootname = "Object Types"
#       #,width = "100%"
#       #,height = "20%"
#       )
# })
#############################################################
# call ui and server
shinyApp(ui, server)
library(shiny)
library(shinyWidgets)
library(shinydashboard)
####### ALL LIBRARIES USED ###########
###### DATA MANIPULATION ######
options(stringsAsFactors = FALSE)
library(dplyr) # for main data manipulations
library(leaflet) # for leaflet map
library(leaflet.providers) # leaflet backgrounds
library(treemap) # base treemap
library(d3treeR) # interactive treemap
# circle colors
library(viridisLite)
#############################################################
# global lists
# all objects user list
objTypes <- c(
"litter" # 1
,"greaseGumStains" # 2
,"graffiti" # 3
,"needles" # 4
,"brokenGlass" # 5
,"poopUrine"# 6
)
# all other user list
otherTypes <- c(
"trashCanIssue" # 1
,"streetFurniture" # 2
,"largeItem" # 3
,"emptyTreeHole" # 4
,"treeIssueWeeds"# 5
,"otherIssue" # 6
)
# total: 12
# all color hex list
colors <- c(
)
#############################################################
# global data
# base csv data
# cleaned via raw/clean_script.R
# used for base map data layer
# will be manipulated later on
raw <- read.csv("raw/clean_rubbish.csv") %>%
subset(lat < 37.785)
# dataframe for manipulation of the raw df to store
# the data points that appear only on the screen.
# used for overlat plot graphs
onscreen_plotdata <- raw
#############################################################
# setup user interface (ui)
###############
# create headbar
header <- dashboardHeader(
# windowTitle = 'Rubbish SoMa West Cleanup'
# ,title = "Rubbish SoMa West Cleanup"
# ,title=div(img(src="rubbish_logo.png"))
title = tags$a(
href='https://www.rubbish.love/'
,target = '_blank'
,tags$img(
src='rubbish_logo.png'
,height='25',width='200px'
)
)
,titleWidth = "230px"
)
################
# create sidebar
sidebar <- dashboardSidebar(
# Custom CSS to hide the default logout panel
# lightpink F4B2F8 # F6A2FC # rubbish E935f2
tags$head(tags$style(HTML('.logo {
background-color: #F6A2FC !important;
}
.navbar {
background-color: #E935f2 !important;
}
')))
# The dynamically-generated user panel
,uiOutput("userpanel")
# stat box toggle switch
,prettyToggle(
inputId = "TFstat"
,label_on = "Showing Stat Box"
,label_off = "Hiding Stat Box"
,icon_on = icon("bar-chart", lib = "font-awesome")
,icon_off = icon("remove", lib = "glyphicon")
,value = TRUE
,status_on = "success"
,status_off = "danger"
,shape = "curve"
,outline = FALSE
,fill = TRUE
,bigger = TRUE
,animation = "pulse"
,width = "100%"
)
# checkboxes for object types
,checkboxGroupButtons(
inputId = "usrTypes"
,justified = TRUE
,direction = "vertical"
,label = "Object Types"
,choices = list(
# add amounts to options
# change if 'change everything mode is on'
"Litter" = objTypes[[1]]
,"Grease and Gum Stains" = objTypes[[2]]
,"Graffiti" = objTypes[[3]]
,"Needles" = objTypes[[4]]
,"Broken Glass" = objTypes[[5]]
,"Poop and Urine" = objTypes[[6]]
)
,selected = objTypes
,status = "primary"
,checkIcon = list(
yes = icon("ok",
lib = "glyphicon"),
no = icon("remove",
lib = "glyphicon"))
)
############
# add options: color changes
# area type choices?
# other classifiers?
############
# add options: map options
# overlay?
# icons?
)
#############
# create body
body <- dashboardBody(
# JS for Text after logo and sidebar button
tags$head(tags$style(HTML(
'.myClass {
font-size: 20px;
line-height: 50px;
text-align: left;
font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
padding: 0 15px;
overflow: hidden;
color: white;
}
'
)))
# write text
,tags$script(HTML('
$(document).ready(function() {
$("header").find("nav").append(\'<span class="myClass"> SoMa West Cleanup </span>\');
})
'))
## css style change
,tags$head(
# Include custom CSS
# courtosy of:
# https://github.com/rstudio/shiny-examples/tree/master/063-superzip-example
includeCSS("styles.css")
)
## custum css style change
# to keep map full height in page
# need to subtract 80px for header
,tags$style(
type = "text/css"
,"#leafletMap {height: calc(100vh - 80px) !important;}"
)
## output leaflet map
,leafletOutput(
"leafletMap"
,width = "100%"
)
# add statistics overlay panel
# if user stat button is true
,conditionalPanel(
condition = "input.TFstat == true",
############# draw overlay panel
absolutePanel(
# settings
id = "controls"
,class = "panel panel-default"
,fixed = TRUE
,draggable = TRUE
,top = 80
,left = "auto"
,right = 25
,bottom = "auto"
,width = 250
,height = "auto"
## header
,h2("Map Statistics")
###########
# render simple graphs
,textOutput("overlay_text")
# lolipop graph for types
# circle packer for map categories
)
)
# map covers this
# ,tags$div(
#   id="cite"
#   ,'Data compiled for '
#   ,tags$em('Coming Apart: The State of White America, 1960â€“2010')
#   ,' by Charles Murray (Crown Forum, 2012).'
# )
)
##########
# merge ui
ui <- dashboardPage(header, sidebar, body)
#############################################################
# creating server
server <- function(input, output)({
output$overlay_text <- renderText({
"
This was a cleanup performed by the Rubbish team
,to get a snapshot of group objects in SoMa west, CA.
Here is some data on the area you are currently looking at!
"
})
#################
# creating graphs
## scraping user input
# grabbing lat and long based on user screen
# this will be used for controlling
# ,the (lat) & (long) range of geocoords
# ,the variable on the overlay plot
## manipulating data
# need to manip dataframe to only contain datapoints
# that are displayed on the screen, so math.
#
# math proof comp. sci. style (for funsies) ##########################
# if:
# x_[a,n,b], y_[a,n,b] exists in world
# s.t. x_[1, .., n], y_[1, .., n] exists for all x that exist on screen
# then:
# f(x,y) = TRUE
#        = x_a <= x_n <= x_b
#    and y_a <= y_1n <= y_b
# got function from the courtosy of:e
InBounds <- reactive({
if (is.null(input$map_bounds)){
# change to my data?
return(onscreen_plotdata[FALSE,])
}
bounds <- input$map_bounds # user screen map bounds
# scraping [x_a, x_b]
lat_rng <- range(bounds$north, bounds$south)
# getting [x_a, x_b]
long_rng <- range(bounds$east, bounds$west)
# subset dataframe
# for <blah> plots
return (
onscreen_plotdata %>%
subset(
lat >= lat_rng[1]
&lat <= lat_rng[2]
&long >= long_rng[1]
&long <= long_rng[2]
)
)
})
###### 2. Leaflet Map
output$leafletMap <- renderLeaflet({
# coord for rough middle of plot
# for map reboot, in middle of types chosen
viewLatLong <- raw %>%
subset(type %in% input$usrTypes) %>%
summarise(
meanlat = mean(lat)
,meanlong = mean(long)
)
# can add option for middle of user screen
# based on global option for screen adjust
# mutate data for user input of object types
df <- raw %>%
subset(input$usrTypes == type)
## color function for continuous data based on itemsTagged
colorContinuous <- colorBin(
# function for color of collection types
palette =
c(
"#E935f2" # diverging CCDA25 # rubbish E935f2
,"#F6A2FC" # lightpink F4B2F8
)
############################################### # #
# add option to change this depending on screen
############################################### # #
,domain = c(1,250)
,bins = 2
,reverse = TRUE
# ,pretty = TRUE
)
df %>%
# send data to leaflet map
leaflet(
## global map settings
# size settings
width = "100%"
,height = "100%"
) %>%
setView(
# set initial view to middle of data
lng= viewLatLong[['meanlong']]
,lat= viewLatLong[['meanlat']]
# initial zoom, fits all points
,zoom= 15.2
) %>%
addProviderTiles(
# backgrounds
"CartoDB.DarkMatter"
# ,"Stamen.Toner"
) %>%
addCircles(
# circle settings
lng = ~long
,lat = ~lat
,radius = ~itemsTagged*0.2
,color = ~colorContinuous(itemsTagged)
)
})
})
# ##### 1. Treemap of object sizes
# output$treeMap <- renderD3tree2({
#
#   # get totals for all types
#   total <- raw %>%
#     subset(type %in% input$usrTypes) %>%
#     summarise(
#       total = sum(itemsTagged)
#     ) %>%
#     as.numeric()
#
#   # create base png treemap
#   treemap <- raw %>%
#     # manipulate data
#     subset(type %in% input$usrTypes) %>%
#     group_by(type, street) %>%
#     summarise(
#       count = sum(itemsTagged)
#       ,percent = sum(itemsTagged)/total*100
#     ) %>%
#     arrange(-count) %>%
#     # call basic tree map
#     treemap(
#       # base settings
#       index=c('type', 'street')
#       ,draw = FALSE
#       ,force.print.labels = FALSE
#       ,vSize = 'count'
#       #,vColor = 'color'
#       ,type ="index"
#       ,palette = "Set2"
#       ,bg.labels = c("white")
#       ,align.labels = list(
#         c("center", "center"),
#         c("right", "bottom")
#       )
#     )
#
#   # create interactive treemap
#   treemap %>%
#     d3tree2(
#       rootname = "Object Types"
#       #,width = "100%"
#       #,height = "20%"
#       )
# })
#############################################################
# call ui and server
shinyApp(ui, server)
